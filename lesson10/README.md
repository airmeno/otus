# Lesson 10 (Processes)

## Задачи 

1. Реализация ps ax через bash используя анализ /proc.
2. Написать свою реализацию lsof.
3. Реализовать 2 конкурирующих процесса по CPU. Пробовать запустить с разными nice.


### Решение. Задача 1

Решение будет состять в использовании скрипта на bash с подбором и форматировнаием информации из псевдофайловой системы /proc

1. Посмотрим вывод команды ps -ax и определим поля 
```
   PID TTY      STAT   TIME COMMAND
```

2. Основную информацию возмем из файла /proc/$pid/stat, /proc/$pid/cmdline и /proc/$pid/fd/, где pid - номер процесса

Поля:
```
PID - Номер процесса
TTY - запущенный терминал, значение 0 - процесс выполняется не в терминале
STAT - состояние процесса 
TIME - процессорное время затраченное на процесс разделенное на значение процессорного такта в машинных часах 
COMMAND - имя процесса и аргументы 
```

> Дополнительно: 
Состояния процессов STAT
```
R	Выполняется. Процесс выполняется или готов к выполнению
S	Приостановлен. Процесс временно не выполняется; скорее всего, находится в ожидании определенного события, такого как нажатие клавиши или прибытие сетевого пакета
D	Приостановлен без возможности прерывания. Процесс ожидает завершения операции ввода/вывода, например, дисковым устройством
T	Остановлен. Процесс принудительно остановлен
Z	Недействующий процесс-«зомби». Это дочерний процесс, который завершился, но не был удален родителем
<	Высокоприоритетный процесс. Потребляют больше процессорного времени, оставляя меньше другим процессам
N	Низкоприоритетный процесс. Получает процессорное время в последнюю очередь
```
Значения полей /proc/pid/stat - [https://kb.novaordis.com/index.php//proc/pid/stat](https://kb.novaordis.com/index.php//proc/pid/stat)

#### Формируем скрипт 

3. Функция (перевод TIME из целого числа в сек во время 0:00): 
```
secconverttime() {
 ((m=(${1}%3600)/60))
 ((s=${1}%60))
 printf "%01d:%02d\n" $m $s
}
```
4. Переменная (значение процессорного такта в машинных часах (интевалы в сек). Нужно для расчета процессорного времени на каждый процесс):
```
clk_tck=$(getconf CLK_TCK)
```

5. Скрипт - [psax.sh](psax.sh)

6. Условие на вывод значения TTY 
```
tty* - терминалы (консоли) 
pts/* - псевдотерминалы
```
По условию, если значение 0, то процесс выполняется вне терминала и присваиваем значение "?", если не 0, то ищем в каталоге /proc/$pid/fd/ первое значение 'pts\|tty' и убираем /dev из значения.

>разница между терминалом и пвсевдотерминалом в том что, в терминалах процесс читает/пишет данные в /dev/tty*, а стандартные ввод / вывод клавиатура и экран. Псевдотерминал - всё, что читает/пишет процесс в /dev/pts/* обрабатывается другим процессом, передаваемое ядром от одного к другому процессу.

### Решение. Задача 2

Данный скрипт анализирует псевдофайловую систему /proc, перебирая каждый запущенный процесс и выводит информацию: какой процесс имеет доступ к файлу (COMMAND), PID процесса, пользователь (USER) и сам файл (NAME). 

По сути является очень простой реализацией lsof.

Скрипт - [lsof.sh](lsof.sh)


### Решение. Задача 3

Запустим 2 одинаковых процесса с разными значениями nice в фоновом режиме и замерим время выполнения каждой задачи. 

Процесс:
```
dd if=/dev/zero of=/tmp/nice.img bs=1M count=1024
```

Значения nice:
* наибольший приоритет: -19
* наименьший приоритет: 20

Для замера значения времени исполнения воспользуемся командой time.

Скрипт:
```
#/bin/bash

time nice -n -20 su -c "dd if=/dev/zero of=/tmp/nice1.img bs=1M count=1024" &  
time nice -n 19 su -c "dd if=/dev/zero of=/tmp/nice2.img bs=1M count=1024" &
```

И результат выполнения:
```
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB) copied, 0.382358 s, 2.8 GB/s

real    0m0.464s
user    0m0.001s
sys     0m0.437s

1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB) copied, 0.783844 s, 1.4 GB/s

real    0m0.879s
user    0m0.003s
sys     0m0.435s
```
Значения отличаются практически в 2 раза.
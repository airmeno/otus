# Lesson 35 (OpenVPN)

## Задача

```
1. Между двумя виртуалками поднять vpn в режимах:
  - tun 
  - tap
  Прочуствовать разницу.

2. Поднять RAS на базе OpenVPN с клиентскими сертификатами, 
   подключиться с локальной машины на виртуалку.
```

## OpenVPN

Решением является [vagrantfile](vagrantfile), который автоматически поднимает Server и Client с установленным VPN соединением (через tun).

### 1.  Поднять RAS на базе OpenVPN с клиентскими сертификатами

Параметры стенда:

```
Сервер:

Linux CentOS 7
IP: 192.168.10.10
Дополнительный loopback: 10.10.10.10/32
Диапазон VPN IP: 172.16.10.0/24

Клиент:

Linux CentOS 7
IP: 192.168.10.20
```

**Задача:** получить доступ к адресу 10.10.10.10 через VPN подключение клиента.

На сервере создадим дополнительный loopback интерфейс, который будет выступать в качестве адреса за vpn сетью. Наша задача получить доступ к loopback.


Установим пакеты:

```
yum install epel-release
yum install openvpn easy-rsa
```

Разрешаем форвард (переслыка) пакетов между интерфейсами:

```
net.ipv4.ip_forward=1
```

**Сертификаты**

Поднимем центр сертификации на базе Easy-RSA:

```
cd /usr/share/easy-rsa/3
```

Чтобы ускорить процесс создания ключей, создаем шаблон переменных для создания сертификатов:

```
cat vars

export KEY_COUNTRY="RU"
export KEY_PROVINCE="Moscow"
export KEY_CITY="Moscow"
export KEY_ORG="Company Name"
export KEY_EMAIL="mail@domain.com"
export KEY_CN="Company"
export KEY_OU="IT"
export KEY_NAME="openvpn-server.domain.com"
export KEY_ALTNAMES="openvpn-server"
export EASYRSA_KEY_SIZE=2048
export EASYRSA_ALGO=rsa
export EASYRSA_CA_EXPIRE=3650
export EASYRSA_CERT_EXPIRE=3650
```

Применим переменные

```
. ./vars
```

Инициализируем PKI — инфраструктуру публичных ключей (Public Key Infrastructure):

```
./easyrsa init-pki
```

Генерируем корневой сертификат, создаем удостоверяющий центр CA:

```
./easyrsa build-ca
```

build-ca создаст два файла: ca.key и ca.crt. ca.key это приватный ключ центра CA, он секретный, его нельзя переносить на другие узлы сети, а ca.crt открытый, его и будем передавать на узлы серверов и клиентов OpenVPN.

Задаем пароль и вводим имя (Common Name). Заданый пароль защищает приватный ключ удостоверяющего центра, и потребуется каждый раз, когда новые создаваемые сертификаты будут подписываться в СА для серверов и клиентов.

Если нет необходимости защищать ключи паролем, то можно задать опцию nopass, но тогда можно легко воспользоваться украденным ключом, созданным без пароля:

```
./easyrsa build-ca nopass
```

Создаем ключ Диффи-Хеллмана, позволяет использовать небезопасный канал для получения общего секретного ключа. В случае похищения ключей исключает расшифрование трафика, записанного еще до этого похищения:

```
./easyrsa gen-dh
```

Статический ключ (хэш-код) аутентификации сообщений HMAC (Hash-based Message Authentication Code) обеспечивает проверку подлинности информации, передаваемой между сторонами и является дополнительной защиты от DoS-атак и флуда.

Для создания ta ключа используем команду:

```
openvpn --genkey --secret pki/ta.key
```

Для создания сертификата сервера необходимо сначала создать файл запроса (vpn-server.req):

```
./easyrsa gen-req vpn-server nopass
```

на Common Name вводим Enter, чтобы использовать настройку из файла vars. На его основе запрашиваем (подписываем) сертификат:

```
./easyrsa sign-req server vpn-server
```

После ввода команды подтверждаем правильность данных, введя yes:

```
Confirm request details: yes
```

и вводим пароль, который указывали при создании корневого сертификата CA.

Если сотрудник уволился или сертификат скомпрометирован, необходимо заблокировать его. Специально для этой цели в OpenVPN предусмотрен список отзыва сертификатов CRL. В CA сгенерируем список отозванных сертификатов:

```
./easyrsa gen-crl
```

будет запрошен пароль доступа к приватному ключу ca.key удостоверяющего центра. Список отзыва сертификатов будет создан в файле easyrsa3/pki/crl.pem.

Заблокировать выданный ранее сертификат (clinet2):

```
./easyrsa revoke client2
```

Далее нужно скопировать новый файл CRL на сервер OpenVPN и перезапустить сервер OpenVPN.

Сертификаты сервера готовы и находятся в каталоге pki.


**Настройки OpenVPN сервера**

Создаем каталог в /etc/openvpn, в котором будут храниться необходимые сертификаты полученные от CA:

```
mkdir /etc/openvpn/server/keys
```

Копируем в него содержимое каталога pki:

```
cp pki/issued/vpn-server.crt pki/private/vpn-server.key pki/dh.pem pki/ca.crt pki/ta.key pki/crl.pem /etc/openvpn/server/keys/
```

Создаем конфигурационный файл:

```
cat /etc/openvpn/server/server.conf

# OpenVPN Server Config
# Указываем какой порт будет слушать наш сервер, по умолчанию 1194
port 1194

# Указываем протокол tcp или udp (tcp-client - пытается установить соединение, tcp-server - ждет подключений)
#proto tcp-server
proto udp4

# На каком устройстве будет работать OpenVPN сервер, tun0 - устройство создается автоматически
dev tun

# Сертификат удостоверяющего центра
ca /etc/openvpn/server/keys/ca.crt

# Сертификат и ключ сервера
cert /etc/openvpn/server/keys/vpn-server.crt
key /etc/openvpn/server/keys/vpn-server.key

# Ключ Диффи-Хельмана используется для защиты передаваемых ключей по открытому каналу
dh /etc/openvpn/server/keys/dh.pem

# Список отозванных сертификатов
crl-verify /etc/openvpn/server/keys/crl.pem

# Секретный TLS ключ
tls-auth /etc/openvpn/server/keys/ta.key 0

# Тип шифрования AES 256 bit
cipher AES-256-CBC

# Подсеть в которой будут работать клиенты VPN сервера
server 172.16.10.0 255.255.255.0

# Файл куда будут записываться IP адреса выданные клиентам
ifconfig-pool-persist ipp.txt

# Выдаем пользователям необходимые маршруты (192.168.1.0 - локальная сеть)
push "route 10.10.10.0 255.255.255.0"

# Выдаем клиентам IP адрес DNS сервера (тут сервер внутри локальной сети для определения DNS имен)
push "dhcp-option DNS 192.168.10.10"

# Выдаем клиентам DNS суффикс нашей локальной сети
#push "dhcp-option DOMAIN domain.ru"

# Разрешаем подключенным клиентам OpenVPN сервера соединяться друг с другом
client-to-client

# Включаем возможность указания индивидуальных настроек для клиентов OpenVPN сервера
client-config-dir ccd

# Если необходимо разрешить нескольким пользователям подключаться по одному ключу (необходимо снять комментарий)
#duplicate-cn

# Проверяем состояние клиента, отправляем пакеты каждые 10 сек. если в течении 120 сек. клиент не ответил, то он считаться отключенным
keepalive 10 120

# Используем сжатие трафика (если не нужно то можно закомментировать)
comp-lzo

# Максимальное количество подключенных клиентов
max-clients 100

# Не перечитавать файлы ключей при перезапуске туннеля
persist-key

# Оставить без изменения устройства tun/tap при перезапуске OpenVPN
persist-tun

# Записи о состоянии подключенных клиентов и т.п. (лог файл)
status /var/log/openvpn/openvpn-status.log

# Уровень логирования: 0 в лог попадают только записи о критических ошибках сервера, принимает значение от 0 до 11.
verb 0
# Количество записей после которых будет производиться запись в лог
mute 20

# режим работы сервера
mode server

# работа в режиме демона
daemon
```

Создаем каталог для логов сервера:

```
mkdir /var/log/openvpn
```

Папка индивидуальных настроек для клиентов OpenVPN сервера
```
mkdir /etc/openvpn/server/ccd
```
Разрешаем автоматический старт сервиса OpenVPN:
```
systemctl enable openvpn-server@server
```
И запускаем его:
```
systemctl start openvpn-server@server
```

Проверка сосотяния:

```
systemctl status openvpn-server@server

ip a - Проверка наличия туннельного адаптера tun0

ss -ltupn | grep 1194 
```

> Если возникает ошибка чтения конфигурации, создаем софтлинк на конфиг

```
ln -s /etc/openvpn/server/server.conf /etc/openvpn/server.conf
```

**Настройка OpenVPN-клиента**

Установка пакетов:

```
yum install epel-release
yum install openvpn 
```

Для настройки клиента необходимо на сервере CA сгенерировать сертификаты:

```
cd /usr/share/easy-rsa/3
```

Запускаем еще раз vars:

```
. ./vars
```

Создаем запрос и сам сертификат:

```
./easyrsa gen-req vpn-client nopass
./easyrsa sign-req client vpn-client
```

Подтверждаем правильность данных и вводим пароль корневого сертификата. В данном примере мы создадим сертификат для vpn-client. 

Переносим сертификаты на клиента

```
cp pki/issued/vpn-client.crt pki/private/vpn-client.key pki/ca.crt pki/ta.key /etc/openvpn/client/
```

Создаем конфигурационный файл:

```
# OpenVPN Client Config
# Тип подключения - клиент
client

# Через какое устройство подключаемся
dev tun0

# Через какой протокол работаем, такой же как на сервере
proto udp

# Адрес OpenVPN сервера и его порт (можно указать IP или URL)
remote 192.168.10.10 1194

# Тип шифрования, как на OpenVPN сервере
cipher AES-256-CBC

# Сертификат удостоверяющего центра
ca /etc/openvpn/client/ca.crt

# Сертификат и ключ клиента
cert /etc/openvpn/client/vpn-client.crt
key /etc/openvpn/client/vpn-client.key

# Клиент поддерживает шифрование
tls-client

# Указываем путь к ключу TLS
tls-auth /etc/openvpn/client/ta.key 1

# защита от mitm-атак, путем проверки серверных сертификатов
remote-cert-tls server

# Не кэшировать пароли в памяти
auth-nocache

# Включаем компрессию данных
comp-lzo

persist-key
persist-tun

# Для клиентов с нестабильным доступом, например Wi-Fi
resolv-retry infinite

# Не использовать специфический (динамический) порт для работы
nobind

keepalive 10 120

# Уровень логирования 0 в лог попадают только записи о критических ошибках, принимает значение от 0 до 11
verb 0

# Количество записей после которых будет производиться запись в лог
mute 20
```

Разрешаем автоматический старт сервиса OpenVPN:

```
systemctl enable openvpn@client
```

И запускаем его:

```
systemctl start openvpn@client
```

Проверка состояния:

```
systemctl status openvpn@client

ip a - Проверка наличия туннельного адаптера tun0
```

> Если возникает ошибка чтения конфигурации, создаем софтлинк на конфиг

```
ln -s /etc/openvpn/client/client.conf /etc/openvpn/client.conf
```

**Изменение стандартного порта (1194) и настройки SELinux**

```
[root@ovpn-server vagrant]# semanage port -l | grep openvpn_port_t
openvpn_port_t                 tcp      1194
openvpn_port_t                 udp      1194

```

Если необходимо настроить на другой порт, например 443 (у многих провайдеров бывают закрыты порты кроме 80 и 443):

```
semanage port -a -t openvpn_port_t -p udp 443

[root@ovpn-server vagrant]# semanage port -l | grep openvpn_port_t
openvpn_port_t                 tcp      1194
openvpn_port_t                 udp      443, 1194
```
443 (tcp) - занят другим.

Настройки для Ansible

```
- name: 'Allow openvpn port to SELinux'
  seport:
    ports: 443
    proto: udp
    setype: openvpn_port_t
    state: present
```


### Итог

Данный процесс автоматизирован заранее созданными сертификатами и сборокой с помощью Ansible. При `vagrant up` поднимается описанный стенд.

При обращениии к созданному loopback интерфейсу по адресу 10.10.10.10 имеем:

```
[vagrant@ovpn-client ~]$ ping 10.10.10.10
PING 10.10.10.10 (10.10.10.10) 56(84) bytes of data.
64 bytes from 10.10.10.10: icmp_seq=1 ttl=64 time=1.19 ms
64 bytes from 10.10.10.10: icmp_seq=2 ttl=64 time=5.94 ms
64 bytes from 10.10.10.10: icmp_seq=3 ttl=64 time=4.70 ms
^C
--- 10.10.10.10 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2004ms
rtt min/avg/max/mdev = 1.195/3.945/5.940/2.010 ms


[vagrant@ovpn-client ~]$ ip r
default via 10.0.2.2 dev eth0 proto dhcp metric 100 
10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15 metric 100 
10.10.10.0/24 via 172.16.10.5 dev tun0 
172.16.10.0/24 via 172.16.10.5 dev tun0 
172.16.10.5 dev tun0 proto kernel scope link src 172.16.10.6 
192.168.10.0/24 dev eth1 proto kernel scope link src 192.168.10.20 metric 101 
```

Как видим, интерефейс доступен, маршруты просписаны через tun0 интерфейс.

> Не затрагиваем вопросы файрвола и маскарадинга. Конечно на боевом сервере необходимы эти настройки в зависимости от выбранного порта для OpenVPN.

### 2. Разница между tun и tap

Если нужно объединить две сети с разной адресацией, то используем **tun**. Например подключаемся из сети 192.168.100.0/24 к 192.168.0.0/24 для взаимного совместного доступа.

Если же задача объединить 2 удаленные сети в единое адресное пространство, например сделать и в офисе, и в филиале единую сеть 192.168.0.0/24, то используем **tap** интерфейс и назначаем в сетях непересекающиеся адреса из одной подсети. То есть оба офиса окажутся в одном широковещательном домене и смогут передавать данные с помощью широковещания на канальном уровне OSI. В таком состоянии openvpn работает в режиме моста.

https://ru.wikipedia.org/wiki/TUN/TAP

> Такие потребности, например, могут возникнуть и при наличии серверов лицензирования, которые работают на канальном уровне, приходится подключаться по L2.

Наш OpenVPN сконфигурирован через tun. Проверим скорость передачи данных с клиента на сервер в туннеле:

```
[root@ovpn-server vagrant]# iperf3 -s


[root@ovpn-client vagrant]# iperf3 -c 172.16.10.1 -t 30-i 5


[ ID] Interval           Transfer     Bandwidth       Retr
[  4]   0.00-29.73  sec   286 MBytes  80.6 Mbits/sec  300             sender
[  4]   0.00-29.73  sec  0.00 Bytes  0.00 bits/sec                  receiver
```
```
-s, --server
-c, --client (адрес соединения)
-t, --time (сколько по времени производить замер)
-i, --interval (через сколько выдавать промежуточный результат)
```

Перенастроим OpenVPN на TAP. Внесем изменения в конфиг файлы сервера и клиента и перезапустим:

```
dev tap
```

```
[ ID] Interval           Transfer     Bandwidth       Retr
[  4]   0.00-8.36   sec  77.7 MBytes  78.0 Mbits/sec   43             sender
[  4]   0.00-8.36   sec  0.00 Bytes  0.00 bits/sec                  receiver
```

В данном случае режим tun показывает немного лучший результат, но в реальных условиях разница будет более ощутимой. Режим tap обычно используется в необходимых случаях (L2 связанность), в остальных же случаях используется tun.


### Выводы

У OpenVPN имеется существенный недостаток - его работа в UserSpace и при больших скоростях канала начинаются потери пакетов (в TCP это компенсируется особенностью протокола). Для организации высокоскоросного соединения site-to-site желательно смотреть в сторону других решений, например, WireGuard. Однако при разворачивании site-to-client решений - это очень гибкий инструмент с широкими возможностьями. 